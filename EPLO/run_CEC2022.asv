% main.m – 比较多种元启发式算法，并输出平均适应度和最优适应度
clc;
clear;
close all;

%% 基本参数设置
nPop     = 30;    % 种群规模
Max_iter = 500;   % 最大迭代次数
dim      = 10;    % 维度（可根据需求修改：2、10、20 等）

% 选择 CEC2022 测试函数编号
Function_name = 12;  % 在 1–12 之间取值
[lb, ub, dim, fobj] = Get_Functions_cec2022(Function_name, dim);

% 重复实验次数（用于计算平均适应度）
numRuns = 30;

%% 待比较的算法列表
% 每个条目包含：{函数句柄, 算法名称字符串}
algorithms = { ...
    @WOA,  "WOA"; ...
    @HHO,  "HHO"; ...
    @GOOSE,"GOOSE"; ...
    @AOO,  "AOO"; ...
    @DAOA, "DAOA"; ...
    %@SCA,  "SCA"; ...
    @ALO,  "ALO"; ...
    @BA,   "BA"; ...
    @GSA,  "GSA"; ...
};

numAlgos = size(algorithms, 1);

%% 预分配存储
Optimal_results = struct();
for i = 1:numAlgos
    Optimal_results(i).Algorithm     = algorithms{i,2};
    Optimal_results(i).BestScores    = zeros(1, numRuns);       % 每次运行的最优值
    Optimal_results(i).Convergence   = zeros(numRuns, Max_iter);% 每次运行的收敛曲线
    Optimal_results(i).RunTime       = zeros(1, numRuns);       % 每次运行耗时
end

%% 多次运行并记录数据
for i = 1:numAlgos
    algoFunc = algorithms{i,1};
    algoName = algorithms{i,2};
    fprintf('Running %s ...\n', algoName);
    
    for runIdx = 1:numRuns
        rng('shuffle');  % 随机种子
        tic;
        
        % 调用对应算法
        [bestScore, bestPos, convCurve] = algoFunc(nPop, Max_iter, lb, ub, dim, fobj);
        
        runTime = toc;
        
        % 存储
        Optimal_results(i).BestScores(runIdx)   = bestScore;
        Optimal_results(i).Convergence(runIdx,:) = convCurve;
        Optimal_results(i).RunTime(runIdx)      = runTime;
    end
    
    % 计算平均最优值和最优最优值
    Optimal_results(i).AvgBestScore = mean(Optimal_results(i).BestScores);
    Optimal_results(i).MinBestScore = min(Optimal_results(i).BestScores);
    Optimal_results(i).StdBestScore = std(Optimal_results(i).BestScores);
    
    % 计算平均收敛曲线（对 numRuns 次迭代历程取均值）
    Optimal_results(i).AvgConvergence = mean(Optimal_results(i).Convergence, 1);
    
    % 计算平均耗时
    Optimal_results(i).AvgTime = mean(Optimal_results(i).RunTime);
end

%% 显示结果（平均最优值 & 最优最优值 & 耗时）
fprintf('\n===== 优化结果 (函数 F%d, 维度 %d, 迭代次数 %d, 种群大小 %d) =====\n', ...
        Function_name, dim, Max_iter, nPop);
fprintf('%-10s %-20s %-20s %-15s\n', '算法', '平均最优值', '全局最优值 (best)', '平均耗时(s)');
for i = 1:numAlgos
    algName = Optimal_results(i).Algorithm;
    avgBS   = Optimal_results(i).AvgBestScore;
    minBS   = Optimal_results(i).MinBestScore;
    avgT    = Optimal_results(i).AvgTime;
    fprintf('%-10s %-20.3e %-20.3e %-15.3f\n', ...
            algName, avgBS, minBS, avgT);
end

%% 绘制各算法平均收敛曲线
figure('Color', [1 1 1], 'Position', [500, 500, 600, 500]);
colors  = lines(numAlgos);
markers = {'o','s','d','^','v','>','<','p'};

% 判断是否使用对数坐标
useLog = true;
if any(Function_name == [9,11,16])
    useLog = false;
end

hold on;
for i = 1:numAlgos
    avgCurve = Optimal_results(i).AvgConvergence;
    if useLog
        semilogy(1:Max_iter, avgCurve, ...
            'Color', colors(i,:), ...
            'Marker', markers{i}, ...
            'MarkerIndices', 1:100:Max_iter, ...
            'LineWidth', 1.5);
    else
        plot(1:Max_iter, avgCurve, ...
            'Color', colors(i,:), ...
            'Marker', markers{i}, ...
            'MarkerIndices', 1:100:Max_iter, ...
            'LineWidth', 1.5);
    end
end
grid on;
title(sprintf('F%d Convergence (Dim=%d)', Function_name, dim), 'FontSize', 16);
xlabel('Iteration', 'FontSize', 16);
ylabel('Fitness Value', 'FontSize', 16);

legend({Optimal_results.Algorithm}, 'Location', 'bestoutside', 'FontSize', 14);

% 调整参数框尺寸并放大字体

hold off;

%% （可选）保存结果
% save(sprintf('F%d_dim%d_results.mat', Function_name, dim), 'Optimal_results');
